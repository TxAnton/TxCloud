          Ассемблер для IBM PC. Глава 4                             79


          
          ГЛАВА 4
          ------------------------------------------------------------
          
          Ассемблирование и выполнение программ
          
          Цель:   показать  процессы   ассемблирования,  компановки  и
          выполнения программ.
          
          ВВЕДЕНИЕ
          ------------------------------------------------------------
          
             В  данной  главе  объясняется,  как  ввести  в  компьютер
          исходный  ассемблерный  текст   программы,  как  осуществить
          ассемблирование,  компановку  и выполнение  программы. Кроме
          того,  показана  генерация таблицы  перекрестных  ссылок для
          целей отладки.
             
          ВВОД ПРОГРАММЫ
          ------------------------------------------------------------
          
             На рис.3.2.  был показан только исходный текст программы,
          предназначенный  для ввода с  помощью  текстового редактора.
          Теперь  можно использовать  DOS EDLIN  или  другой текстовый
          редактор  для  ввода  этой  программы.  Если  вы  никогда не
          пользовались  программой EDLIN,  то именно сейчас необходимо
          выполнить ряд упражнений из руководства по  DOS. Для запуска
          программы  EDLIN  вставте   дискету  DOS  в   дисковод  A  и
          форматизованную  дискету в  дисковод  B.  Чтобы  убедиться в
          наличии на  дискете свободного  места для  исходного текста,
          введите CHKDSK B:. Для винчестера во всех следующих примерах
          следует  использовать  C:  вместо  B:.  Для  ввода  исходной
          программы EXASM1, наберите команду
             
                         EDLIN В:EXASM1.ASM [Return]
             
             В результате  DOS загрузит   EDLIN  в  памяти  и появится
          сообщение "New file"  и приглашение "*-". Введите команду  I
          для  ввода  строк,  и  затем  наберите   каждую ассемблерную
          команду так,  как они изобpажены  на   рис.  3.2. Хотя число
          пробелов в тексте для ассемблера не  существенно, старайтесь
          записывать метки, команды, операнды  и комментарии, выровнен
          ными в колонки,  программа будет   более  yдобочитаемая. Для
          этого  в EDLIN используется  табуляция  через  каждые восемь
          позиций.
             После ввода программы убедитесь в ее  правильности. Затем
          наберите E (и Return)  для завершения EDLIN. Можно проверить
          наличие программы в каталоге на диске, введите
             
                         DIR B:              (для всех файлов)
                    или  DIR B:EXASM1.ASM    (для одного файла)
             


          
          Ассемблер для IBM PC. Глава 4                             80


             Если  предполагается  ввод   исходного   текста  большего
          объема,  то лучшим применением будет полноэкранный редактор.
          Для  получения  распечатки  программы  включите   принтер  и
          установите в него бумагу.  Вызовите программу PRINT (для DOS
          2.0 и старше). DOS загрузит программу в память и распечатает
          текст на принтере:
             
                         PRINT B:EXASM1.ASM [Return]
             
             Программа EXASM.ASM еще не может быть  выполнена - прежде
          необходимо  провести  ее  ассемблирование  и  компановку.  В
          следующем   pазделе   показана   эта   же   программа  после
          ассемблирования и пояснены этапы ассемблирования и получения
          листинга.
             
          ПОДГОТОВКА ПРОГРАММЫ ДЛЯ ВЫПОЛНЕНИЯ
          ------------------------------------------------------------
          
             После  ввода  на  диск  исходной  программы   под  именем
          EXASM1.ASM необходимо  проделать два  основных  шага, прежде
          чем  программу  можно  будет  выполнить.  Сначала необходимо
          ассемблиpовать  программу,  а  затем  выполнить  компановку.
          Программисты на языке бейсик могут выполнить программу сразу
          после ввода исходного текста,  в то время как для ассемблера
          и компиллярных языков нужны шаги трансляции и компановки.
             Шаг ассемблирования включает в  себя трансляцию исходного
          кода в машинный объектный код и генерацию OBJ-модуля. Вы уже
          встречали примеры машинного кода в главе 2 и примеры исxодно
          го текста в этой главе.
             OBJ-модуль уже более приближен к исполнительной форме, но
          еще не готов к выполнению. Шаг компановки включает преобразо
          вание  OBJ-модуля  в  EXE  (исполнимый)  модуль,  содержащий
          машинный код.  Прогрпмма  LINK,  находящаяся  на  диске DOS,
          выполняет следующее:
             
          1.   Завершает формирование  в  OBJ-модуле  адресов, которые
               остались неопределенными после  ассемблирования. Во мно
               гих следующих программах такие адреса  ассемблер отмеча
               ет как ----R.
          2.   Компанует, если необходимо, более одного отдельно ассем
               блированного модуля в одну загрузочную (выполнимую) про
               грамму;  возможно две или  более  ассемблерных программ
               или ассемблерную   программу с программами, написанными
               на  языках  высокого  уровня,  таких  как  Паскаль  или
               Бейсик.
          3.   Инициализирует   EXE-модуль   командами   загрузки  для
               выполнения.
          
             После  компановки  OBJ-модуля   (одного   или   более)  в
          EXE-модуль,  можно выполнить EXE-модуль любое число раз. Но,
          если необходимо  внести  некоторые  изменения  в EXE-модуль,
          следует скорректировать  исходную  программу, ассемблировать
          ее в другой  OBJ-модуль и выполнить  компановку OBJ-модуля в

          
          Ассемблер для IBM PC. Глава 4                             81


          новый EXE-модуль.  Даже,  если  эти шаги  пока остаются непо
          нятными,  вы  обнаружите,  что, получив немного навыка, весь
          процесс подготовки EXE-модуля будет  доведен до автоматизма.
          Заметьте: определенные типы EXE-программ можно преобразовать
          в  oчень  эффективные  COM-программы.   Предыдущие  примеры,
          однако,  не cовсем подходят  для этой  цели.   Данный вопрос
          рассматривается в главе 6.
             
          АССЕМБЛИРОВАНИЕ ПРОГРАММЫ
          ------------------------------------------------------------
          
             Для  того,  чтобы выполнить исходную ассемблерную програм
          му,  необходимо прежде  провести ее ассемблирование  и затем
          компановку.  На дискете с ассемблерным  пакетом  имеются две
          версии aссемблера.  ASM.EXE - сокращенная версия с отсутстви
          ем  некоторых  незначительных  возможностей   и  MASM.EXE  -
          полная версия. Если размеры памяти позволяют, то используйте
          версию  MASM (подробности см.  в соответствующем руководстве
          по ассемблеру).
             Для  ассемблирования,   вставте  ассемблерную  дискету  в
          дисковод  A,  а дискету с исходной программой в  дисковод B.
          Кто имеет винчестер могут использовать в  следующих примеpах
          C вместо A и B. Простейший вариант вызова программы это ввод
          команды MASM  (или  ASM),  что приведет к загрузке программы
          ассемблера с диска в память. На экране появится:
             
                         source filename [.ASM]:
                         object filename [filename.OBJ]:
                         source listing [NUL.LST]:
                         cross-reference [NUL.CRF]:
             
             Курсор при этом расположится  в конце первой  строки, где
          необходимо указать имя файла.  Введите номер дисковода (если
          он не  определен умолчанием)  и имя файла  в следующем виде:
          B:EXASM1.  Не следует набирать тип файла ASM,  так как ассем
          блер подразумевает это.
             Во-втором  запросе предполагается  аналогичное  имя файла
          (но  можно его  заменить).  Если  необходимо,  введите номер
          дисковода B:.
             Третий запрос  предполагает,  что листинг ассемблирования
          программы не требуется.  Для получения листинга на дисководе
          B наберите B: и нажмите Return.
             Последний  запрос предполагает,  что листинг перекрестных
          cсылок не требуется.  Для получения листинга на дисководе B,
          наберите B: и нажмите Return.
             Если вы хотите оставить значения по умолчанию,  то в трех
          последних  запросах  просто  нажмите  Return.  Ниже приведен
          пример  запросов  и ответов,  в результате которых ассемблер
          должен cоздать OBJ, LST и CRF-файлы. Введите ответы так, как
          показано,  за исключением того,  что  номер  дисковода может
          быть иной.
             
                         source filename [.ASM]:B:EXASM1 [Return]

          
          Ассемблер для IBM PC. Глава 4                             82


                         object filename [filename.OBJ]:B: [Return]
                         source listing [NUL.LST]:B: [Return]
                         cross-reference [NUL.CRF]:B: [Return]
             
             Всегда необходимо вводить имя исходного файла  и, обычно,
          запрашивать   OBJ-файл  -   это   требуется  для  компановки
          программы в загрузочный файл.  Возможно потребуется указание
          LST-файла,  особенно, если необходимо проверить сгенерирован
          ный  машинный  код.   CRF-файл  полезен  для  очень  больших
          программ,  где необходимо видеть, какие команды ссылаются на
          какие  поля  данных.  Кроме  того,  ассемблер  генерирует  в
          LST-файле номера строк, которые используются в CRF-файле.
             В приложении 4  "Режимы ассемблирования и редактирования"
          перечислены режимы (опции) для ассемблера версий 1.0 и 2.0.
             Ассемблер преобразует исходные  команды в машинный  код и
          выдает  на  экран сообщения о  возможных  ошибках. Типичными
          ошибками  являются  нарушения   ассемблерных  соглашений  по
          именам, неправильное написание команд (например, MOVE вместо
          MOV),  а  также  наличие  в  опеpандах  неопределенных имен.
          Программа ASM вадает только коды ошибок, которые объяснены в
          руководстве по  ассемблеру,  в  то время  как программа МASM
          выдает и коды ошибок, и пояснения к ним. Всего имеется около
          100 сообщений об ошибках.
             Ассемблер   делает   попытки   скорректировать  некоторые
          ошибки,  но в любом случае  следует  перезагрузить текстовый
          редактор,   исправить  исходную   программу  (EXASM1.ASM)  и
          повторить ассемблирование.
             На  рис.  4.1.  показан листинг,  полученный в результате
          асcемблирования программы и записанный  на  диск  под именем
          EXASM1.LST.
             В начале листинга обратите внимание на реакцию ассемблера
          на  директивы  PAGE  и  TITLE.  Никакие  директивы,  включая
          SEGMENT, PROC, ASSUME и END не генерируют машинных кодов.
             Листинг содержит не только исходный текст, но также слева
          транслированный машинный код в  шестнадцатиричном формате. В
          самой левой колонке находится шест.адреса команд и данных.
             Сегмент стека начинается с относительного  адреса 0000. В
          действительности он  загружается в память  в  соответствии с
          адpесом в регистре SS и нулевым смещением относительно этого
          адpеса.  Директива SEGMENT устанавливает 16-кратный  адрес и
          указывает  ассемблеру,  что  это  есть  начало  стека.  Сама
          директива  не  генерирует  машинный  код.  Команда DB, также
          находится  по  адресу   0000,   содержит   12   копий  слова
          'STACKSEG'; машинный код представлен шест.0C (десятичное 12)
          и шест.  представлением ASCII символов.  (В дальнейшем можно
          использовать  отладчик для просмотра  результатов в памяти).
          Сегмент стека заканчивается по  адресу  шест.  0060, который
          эквивалентен десятичному значению 96 (12х8).
             
          ------------------------------------------------------------
          ------------------------------------------------------------
               Рис. 4.1. Листинг ассемблирования программы
             

          
          Ассемблер для IBM PC. Глава 4                             83


             Сегмент  кода  также начинается  с  относительного адреса
          0000.  Он  загружается в память  в соответствии  с адресом в
          pегистре CS и нулевым смещением  относительно  этого адреса.
          Поскольку  ASSUME является директивой  ассемблеру, то первая
          команда, которая генерирует действительный машинный код есть
          PUSH DS -  однобайтовая команда (1E), находящаяся на нулевом
          смещении.  Следующая команда SUB  AX,AX генерирует двухбайто
          вый   машинный  код (2B C0),  начинающийся с  относительного
          адреса 0001.  Пробел между байтами только  для удобочитаемос
          ти. В данном примере встречаются одно-, двух- и трехбайтовые
          команды.
             Последняя команда  END  содержит  операнд  BEGIN, который
          имеeт отношение к имени команды PROC  по  смещению 0000. Это
          есть адрес сегмента кодов,  с которого начинается выполнение
          после загрузки программы.
             Листинг  ассемблирования программы  EXASM1.LST,  имеет по
          директиве PAGE шиpину  132  символа и может быть распечатан.
          Многие  принтеры  могут   печатать  текст   сжатым  шрифтом.
          Включите ваш принтер и введите команду
             
                              MODE LPT1:132,6
             
             Таблица идентификаторов
             
             За  листингом ассемблирования  программы  следует таблица
          идентификаторов.  Первая часть таблицы содержит определенные
          в программе сегменты и группы вместе с их размером в байтах,
          выравниванием и классом.  Вторая часть содержит идентификато
          ры -  имена полей данных в сегменте данных (в  нашем примере
          их нет) и метки, назначенные командам в сегменте кодов (одна
          в нашем примере).  Для того, чтобы ассемблер не создавал эту
          таблицу, следует указать параметр /N вслед за командой MASM,
          т.е. MASM/N.
             
             Двухпроходный ассемблер
             
             В   процессе  трансляции  исходной   программы  ассемблер
          делает  два просмотра  исходного  текста,  или  два прохода.
          Одной из основных  причин этого являются ссылки  вперед, что
          происходит в том случае,  когда в некоторой команде кодирует
          ся метка, значение которой еще не определено ассемблером.
             В  первом  проходе ассемблер  просматривает  всю исходную
          прогpамму  и строит таблицу  идентификаторов, используемых в
          программе,  т.е.  имен полей  данных и меток  программы и их
          относительных   aдресов   в  программе.   В  первом  проходе
          подчитывается объем объектного кода, но сам объектный код не
          генерируется.
             Во  втором проходе ассемблер  использует таблицу идентифи
          каторов,  построенную в  первом проходе.  Так как теперь уже
          известны  длины и относительные адреса  всех  полей данных и
          команд,  то ассемблер может сгенерировать  объектный код для
          каждой команды.  Ассемблер создает,  если  требуется, файлы:
          OBJ, LST и CRF.

          
          Ассемблер для IBM PC. Глава 4                             84


             
          КОМПАНОВКА ПРОГРАММЫ
          ------------------------------------------------------------
          
             Если в результате  ассемблирования не  обнаружено ошибок,
          то  cледующий  шаг  -   компановка  объектного  модуля. Файл
          EXASM1.OBJ содержит только машинный код  в шестнадцатеричной
          форме.  Так  как программа может загружаться  почти  в любое
          место  памяти  для   выполнения,   то  ассемблер   может  не
          определить   все   машинные   адреса.   Кроме   того,  могут
          использоваться  другие  (под)  программы  для  объединения с
          основной.  Назначением  программы  LINK  является завершение
          определения  адресных ссылок и объединение  (если требуется)
          нескольких программ.
             Для  компановки  ассемблированной  программы  с  дискеты,
          вставте дискету DOS в дисковод  A,  а дискету с программой в
          дисковод   B.   Пользователи   винчестерского   диска  могут
          загрузить компановщик  LINK  прямо  с  дисковода  C. Введите
          команду  LINK  и нажмите клавишу  Return.  После  загрузки в
          память,  компановщик  выдает  несколько запросов (аналогично
          MASM), на которые необходимо ответить:
             
             Запрос компановщика        Ответ          Действие
             
             Object Modules [.OBJ]:     B:EXASM1  Компанует EXASM1.OBJ
             Run file [EXASM1.EXE]:     B:        Создает EXASM1.EXE
             List file [NUL.MAP]:       CON       Создает EXASM1.MAP
             Libraries [.LIB]:          [Return]  По умолчанию
             
             Первый запрос -  запрос имен объектных модулей  для компа
          новки, тип OBJ можно опустить.
             Второй запрос -  запрос имени исполнимого модуля (файла),
          (по   умолчанию  A:EXASM1.EXE).   Ответ  B:  требует,  чтобы
          компановщик создал файл на дисководе  В. Практика сохранения
          одного имени (при  разных  типах)  файла  упрощает  работу с
          программами.
             Третий запрос предполагает, что LINK выбирает значение по
          yмолчанию   -   NUL.MAP  (т.е.  MAP  отсутствует).  MAP-файл
          содержит таблицу имен и размеров сегментов и ошибки, которые
          обнаружит  LINK.   Типичной  ошибкой  является  неправильное
          определение  сегмента  стека.  Ответ  CON  предполагает, что
          таблица будет выведена на  экран,  вместо записи ее на диск.
          Это позволяет сэкономить  место в  дисковой  памяти  и сразу
          просмотреть  таблицу  непосредственно  на  экране.  В  нашем
          примере MAP-файл содержит следующую информацию:
             
               Start     Stop      Length    Name
             
               00000H    00015H    0016H     CODESG
               00020H    0007FH    0060H     STACKSG
             



          
          Ассемблер для IBM PC. Глава 4                             85


             Для  ответа  на  четвертый запрос  -  нажмите Return, что
          укажет  компановщику  LINK  принять  остальные  параметры по
          yмолчанию.  Описание  библиотечных  средств  можно  найти  в
          руководстве по DOS.
             На данном этапе единственной возможной ошибкой может быть
          yказание  неправильных  имен  файлов.  Исправить  это  можно
          только перезапуском  программы LINK.  В приложении 4 перечис
          лен ряд pежимов компановщика LINK.
             
          ВЫПОЛНЕНИЕ ПРОГРАММЫ
          ------------------------------------------------------------
          
             После   ассемблирования  и  компановки   программы  можно
          (наконец-то!)  выполнить ее.  На  рис.  4.2  приведена схема
          команд и шагов для ассемблирования,  компановки и выполнения
          программы EXASM1. Если EXE-файл находится на дисководе B, то
          выполнить ее можно командой:
             
                         B:EXASM1.EXE   или   B:EXASM1
             
             DOS  предполагает,  что файл имеет тип EXE  (или  COM), и
          загружает файл для выполнения.  Но так как наша программа не
          вырабатывает видимых результатов,  выполним  ее трассировкой
          под отладчиком DEBUG. Введите
             
                         DEBUG B:EXASM1.EXE
             
             В результате  DOS загрузит  программу  DEBUG,  который, в
          свою  очередь,  загрузит  требуемый EXE-модуль.  После этого
          отладчик  выдаст  дефис  (-)  в  качестве  приглашения.  Для
          просмотра сегмента стека введите
             
                                   D SS:0
             
             Эту  область  легко  узнать  по  12-кратному дублированию
          константы STACKSEG. Для просмотра сегмента кода введите
             
                                   D CS:0
             
             Сравните машинный код с листингом ассемблера:
             
                         1E2BC050B823010525008BD803 ...
             
             Непосредственные   операнды,   приведенные   в   листинге
          ассемблирования как 0123 и 0025 в памяти представлены в виде
          2301   и  2500   соответственно.  В  данном  случае  листинг
          ассемблирования не вполне соответствует машинному  коду. Все
          двухбайтовые адреса  (слова)  и  непосредственные операнды в
          машинном коде хранятся в обратном порядке.





          
          Ассемблер для IBM PC. Глава 4                             86


             Введите R для просмотра содержимого регистров и выполните
          прогpамму  с  помощью  команды   T  (трассировка).  Обратите
          внимание на воздействие двух команд PUSH на стек - в вершине
          стека теперь  находится  содержимое  регистра  DS  и нулевой
          адрес.
             В  процессе  пошагового   выполнения  программы  обратите
          внимание  на  содержимое  регистров.  Когда  вы  дойдете  до
          команды RET,  можно ввести  Q (Quit -  выход) для завершения
          работы отладчика.
             Используя  команду  dir,  можно  проверить  наличие ваших
          файлов на диске:
             
                              DIR B:EXASM1.*
             
          ------------------------------------------------------------
          ------------------------------------------------------------
                    Рис. 4.2. Схема ассемблирования, компановки
                              и выполнения программы.
             
             В результате  на экране появится  следующие имена файлов:
          EXASM1.BAK (если для  корректировки EXASM1.ASM использовался
          редактор   EDLIN),   EXASM1.ASM,   EXASM1.OBJ,   EXASM1.LST,
          EXASM1.EXE  и  EXASM1.CRF.  Последовательность  этих  файлов
          может быть иной в зависимости от того,  что уже находится на
          диске.
             Очевидно, что разработка ряда программ приведет к занятию
          дискового пространства.  Для проверки оставшегося свободного
          места на диске полезно использовать команду  DOS CHKDSK. Для
          удаления OBJ-,  CRF-,  BAK-  и  LST-файлов  с  диска следует
          использовать команду ERASE (или DEL):
             
                         ERASE B:EXASM1.OBJ, ...
             
             Следует  оставить  (сохранить)  ASM-файл  для последующих
          изменений и EXE-файл для выполнения.
             В  следующем разделе  представлено  определение  данных в
          сегменте данных.  Позже  будет описана  таблица перекрестных
          cсылок.
             
          ПРИМЕР ИСХОДНОЙ ПРОГРАММЫ
          ------------------------------------------------------------
          
             Особенность программы, приведенной на рис. 4.1, состоит в
          том,  что она не  содержит  определения  данных.  Обычно все
          программы  имеют определенные  константы,  рабочие  поля для
          арифметических    вычислений   и    области   для   операций
          ввода-вывода.
             В главе 2 (рис.2.3) была рассмотрена программа в машинных
          кодах,  в которой были  определены  два поля  данных. В этой
          главе на рис.  4.3  приводится аналогичная программа,  но на
          этот раз написанная на языке ассемблера и для  краткости уже
          ассемблированная.   Эта  программа  знакомит  с  несколькими
          новыми особенностями.

          
          Ассемблер для IBM PC. Глава 4                             87


             Сегмент стека содержит директиву DW (Define Word - опреде
          лить cлово),  описывающая  32  слова, в которых генерируется
          неопределенное  значение  обозначенное  знаком  вопроса (?).
          Определение  размера  стека  в  32  слова  является наиболее
          реальным,  так как в больших  программах может потребоваться
          много "прерываний"  для ввода-вывода и вызовов подпрограмм -
          все  они используют  стек.  Определение  стека дублированием
          константы 'STACKSEG'  в примере на pис. 3.2  необходимо лишь
          для удобства при работе с отладчиком DEBUG.
             Замечание: Определяйте размер стека не менее 32 слов. При
          малых размерах  стека ни  ассемблер,  ни компановщик не смо-
          гут определить этого и выполнение программы  может разрушить
          ся самым непредсказуемым образом.
             В  примере на  рис.  4.3 определен сегмент данных DATASG,
          начинающийся по  относительному  адресу  0000.  Этот сегмент
          содержит три значения  в формате  DW.  Поле  FLDA определяет
          слово  (два  байта),  содержащее  десятичное  значение  250,
          которое ассемблер транслирует в шест.  00FA (см.  на рисунке
          слева).
             Поле FLDB  определяет  слово с десятичным  значением 125,
          котоpое транслируется в шест.  007D. Действительные значения
          этих  двух констант в памяти  -  FA00 и 7D00 соответственно,
          что можно проверить c помощью отладчика DEBUG.
             
          ------------------------------------------------------------
          ------------------------------------------------------------
               Рис. 4.3. Листинг ассемблирования программы
                         с сегментом данных.
          
             Поле  FLDC  определяет  слово   с  неизвестным значением,
          обозначенным знаком вопроса (?).
             Сегмент  кода в данном примере имеет имя  CODESG  и отли-
          чается новыми особенностями,  связанными с сегментом данных.
          Во-первых,  директива ASSUME указывает  на определние DATASG
          через регистр DS.  Данной программе не требуется регистр ES,
          но некоторые программисты описывают его  для стандартизации.
          Во-вторых,  после команд PUSH, SUB и PUSH, которые инициали-
          зируют  стек,  следуют две команды, обеспечивающие адресацию
          сегмента данных:
             
                         0004  B8 ---- R     MOV  AX,DATASG
                         0007  8E D8         MOV  DS,AX
             
             Первая  команда  MOV  загружает  DATASG  в   регистр  AX.
          Конечно,  на самом деле команда не может загрузить сегмент в
          регистр - она загружает лишь адрес сегмента DATASG. Обратите
          внимание на машинный код слева:
             
                               B8 ---- R
          
          Четыре дефиса говорят о том,  что ассемблер не  может опреде
          лить  aдрес DATASG;  он  определяется  лишь  когда объектная
          программа будет  скомпанована  и  загружена  для выполнения.

          
          Ассемблер для IBM PC. Глава 4                             88


          Поскольку  загpузчик  может  расположить  программу  в любом
          месте памяти,  асcемблер  оставляет данный  адрес открытым и
          показывает это  символом R;  компановщик должен будет подста
          вить в это место действительный адрес.
             Вторая  команда MOV пересылает  содержимое  регистра AX в
          регистр DS.  Таким образом, данная программа имеет директиву
          ASSUME,  которая соотносит регистр DS с  сегментом данных, и
          команды,  инициализирующие регистр  DS относительным адресом
          DATASG.
             Могут возникнуть  два вопроса по  поводу  этой программы.
          Во-первых,  почему не использовать одну команду для инициали
          зации регистра DS, например,
             
                              MOV  DS,DATASG ?
             
             Дело в том, что не существует команд для непосредственной
          переcылки данных из памяти в регистр DS.  Следовательно, для
          инициализации DS необходимо кодировать две команды.
             Во-вторых,  почему программа инициализирует регистр DS, а
          регистры  SS  и  CS  нет?  Оказывается,  регистры  SS  и  CS
          инициализируются автоматически  при  загрузке  программы для
          выполнения,  а ответственность за инициализацию  регистра DS
          и, если требуется ES, лежит полностью на самой программе.
             Пока  все эти требования  могут  показаться  весьма туман
          ными,  но cейчас нет необходимости понимать их. Все последую
          щие программы используют аналогичную  стандартную инициализа
          цию стека и сегмента данных. Поэтому можно просто копировать
          данные коды  для каждой  новой программы.  Действительно, вы
          можете сохранить на диске стандартную часть  программы и для
          каждой новой программы копировать эту часть  с новым именем,
          и,   используя  затем   редактор,   записать  дополнительные
          команды.
             В  качестве  упражнения,   создайте   с   помощью  вашего
          редактора программу,  приведенную на рис. 4.3,  выполните ее
          ассемблирование  и  компановку.  Затем  с  помощью отладчика
          DEBUG просмотрите сегмент кодов,  сегмент данных, регистры и
          проделайте пошаговое выполнение программы.
             
          ФАЙЛ ПЕРЕКРЕСТНЫХ ССЫЛОК
          ------------------------------------------------------------
          
             В   процессе   трансляции   ассемблер   создает   таблицу
          идентификаторов  (CRF),  которая может  быть  представлена в
          виде  листинга перекрестных ссылок  на метки, идентификаторы
          и  переменные  в  программе.  Для  получения  данного  фала,
          необходимо  на  четвертый  запрос  ассемблера,  oтветить B:,
          полагая, что файл должен быть создан на диске B:
             
                    cross-reference [NUL.CRF]:B: [Return]
             




          
          Ассемблер для IBM PC. Глава 4                             89


             Далее  необходимо  преобразовать  полученный  CRF-файл  в
          отсортиpованную  таблицу перекрестных  ссылок.  Для этого на
          ассемблерном диске имеется  соответствующая программа. После
          успешного  ассемблирования введите команду  CREF.  На экране
          появится два запроса:
             
                         Cref filename [.CRF]:
                         List filename [cross-ref.REF]:
             
             На первый запрос введите имя CRF-файла, т.е. B:EXASM1. На
          второй запрос можно ввести только номер дисковода и получить
          имя по умолчанию.  Такой выбор приведет к записи CRF  в файл
          перекрестных ссылок по имени EXASM1.REF на дисководе B.
             Для  распечатки  файла  перекрестных  ссылок  используйте
          команду DOS  PRINT.  В  приложении  4  приведен  ряд режимов
          программы CREF.
             
          ------------------------------------------------------------
          ------------------------------------------------------------
                    Рис. 4.4. Таблица перекрестных ссылок
             
             На рис.  4.4  показана  таблица  перекрестных  ссылок для
          программы,  приведенной  на  рис.  4.3. Все идентификаторы в
          таблице предcтавлены в  алфавитном порядке и  для каждого из
          них  указаны номеpа  строк  в  исходной  программе,  где они
          определены  и  имеют  ссылки.  Имена  сегментов  и элементов
          данных  представлены  в  алфавитном  поpядке.  Первое  число
          справа в формате n#  указывает на номер строки  в LST-файле,
          где  определен  соответствующий  идентификатор.  Еще  правее
          находятся  числа,  указывающие на номера строк,  где имеются
          cсылки на этот  идентификатор.  Например, CODESG определен в
          строке 17 и имеет ссылки на строках 19 и 32.
             
          ОСНОВНЫЕ ПОЛОЖЕНИЯ НА ПАМЯТЬ
          ------------------------------------------------------------
          
          ▀    Ассемблер преобразует исходную программу в  OBJ-файл, а
               компановщик  -   OBJ-файл  в  загрузочный  EXE-файл.
          ▀    Внимательно  проверяйте   запросы  и ответы  на них для
               программ  (M)ASM, LINK и CREF прежде чем нажать клавишу
               Return. Будьте особенно внимательны при указании  диско
               вода.
          ▀    Программа CREF создает распечатку  перекрестных ссылок.
          ▀    Удаляйте  ненужные  файлы  с  вашего  диска.  Регулярно
               пользуйтесь программой  CHKDSK  для проверки свободного
               места  на  диске.  Кроме  того  периодически создавайте
               резервные  копии  вашей  программы,  храните  резервную
               дискету  и   копируйте  ее   заново  для   последующего
               программирования.
          
          ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ
          ------------------------------------------------------------
          

          
          Ассемблер для IBM PC. Глава 4                             90


          4.1. Введите  команду   MASM  и  ответьте   на  запросы  для
               ассемблирования   программы   по   имени   TEMPY.ASM  с
               получением файлов LST,  OBJ и CRF, полагая, что дискета
               с  программой  находится на  дисководе B.
          
          4.2. Введите команды для программы TEMPY (из вопроса 4.1) а)
               для выполнения через отладчик DEBUG,  б) для непосредст
               венного выполнения  из  DOS.
          
          4.3. Объясните назначение  каждого из  следующих  файлов: а)
               file.BAK,  б)  file.ASM,  в)  file.LST, г) file.CRF, д)
               file.OBJ, е) file.EXE, ж) file.MAP.
          
          4.4. Напишите  две команды  для  инициализации  регистра DS,
               полагая,  что  имя сегмента данных -  DATSEG.
          
          4.5. Составте ассемблерную программу для:
          
               - пересылки  шест. 30  (непосредственное  значение)  в
                 регистр AL;
               - сдвига содержимого регистра AL на оди бит влево
                 (команда SHL);
               - пересылки шест. 18 (непосредственное значение) в
                 регистр BL;
               - умножения регистра AL на BL (команда MUL BL).
          
               Не забывайте команду RET. В программе нет необходимости
               определять  и инициализировать сегмент  данных. Не забы
               вайте также копировать стандартную часть  программы (ос
               нову  программы)  и использовать редактор для  ее разви
               тия.  Выполните ассемблирование и компановку. Используя
               отладчик DEBUG,  проверте сегмент кодов, регистры и про
               делайте пошаговое  выполнение  (трассировку) программы.
          
          4.6. Модифицируйте программу из вопроса 4.5 для:
          
               - определения однобайтовых элементов (директива DB) по
                 имени FLDA, содержащего шест. 28, и по имени FLDB,
                 содержащего шест. 14;
               - определения двухбайтового элемента (директива DW) по
                 имени FLDC, не имеющего значения;
               - пересылки содержимого поля FLDA в регистр AL и сдвига
                 на один бит;
               - умножения содержимого регистра AL на значение в поле
                 FLDB (MUL FLDB);
               - пересылки результата из регистра AX в поле FLDC.
          
               Для данной программы необходим  сегмент данных. Выполни
               те ассемблирование, компановку программы и тестирование
               с помощью отладчика DEBUG.




          
